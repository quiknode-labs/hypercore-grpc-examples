// Order book streaming service for grpc.
//
// Provides L2 (aggregated price levels) and L4 (individual orders) order book
// data via gRPC server-streaming RPCs. The order book state is maintained
// in-memory by the OrderBookProcessor, which consumes BookDiffs and
// OrderStatuses from the existing grpc multiplexer pipeline.

syntax = "proto3";
package hyperliquid;

// Service for streaming real-time order book data.
// L2 provides aggregated price levels (px, total_sz, order_count).
// L4 provides individual order details (user, trigger info, timestamps).
service OrderBookStreaming {
  // Subscribe to L2 aggregated book updates for a coin.
  // Sends a full L2 snapshot after each block is processed.
  rpc StreamL2Book (L2BookRequest) returns (stream L2BookUpdate);

  // Subscribe to L4 full order book for a coin.
  // Sends an initial L4 snapshot, then incremental diffs per block.
  rpc StreamL4Book (L4BookRequest) returns (stream L4BookUpdate);
}

// Request parameters for L2 book streaming.
message L2BookRequest {
  string coin = 1;                     // Symbol (e.g. "BTC", "ETH")
  uint32 n_levels = 2;                 // Max number of price levels (default 20, max 100)
  optional uint32 n_sig_figs = 3;      // Significance figures for price bucketing (2-5)
  optional uint64 mantissa = 4;        // Mantissa for bucketing (1, 2, or 5)
}

// An L2 book update: full snapshot of aggregated price levels at a point in time.
message L2BookUpdate {
  string coin = 1;
  uint64 time = 2;                     // Block timestamp (milliseconds)
  uint64 block_number = 3;
  repeated L2Level bids = 4;           // Aggregated bid levels (best first)
  repeated L2Level asks = 5;           // Aggregated ask levels (best first)
}

// A single aggregated price level.
message L2Level {
  string px = 1;                       // Price as decimal string
  string sz = 2;                       // Total size as decimal string
  uint32 n = 3;                        // Number of individual orders at this level
}

// Request parameters for L4 book streaming.
message L4BookRequest {
  string coin = 1;                     // Symbol (e.g. "BTC", "ETH")
}

// An L4 book update: either a full snapshot or an incremental diff.
message L4BookUpdate {
  oneof update {
    L4BookSnapshot snapshot = 1;       // Full snapshot (sent on subscribe)
    L4BookDiff diff = 2;               // Incremental diff (sent per block)
  }
}

// Full L4 order book snapshot for a single coin.
message L4BookSnapshot {
  string coin = 1;
  uint64 time = 2;
  uint64 height = 3;
  repeated L4Order bids = 4;
  repeated L4Order asks = 5;
}

// Incremental L4 book diff: raw order statuses and book diffs for one block.
// Sent as JSON to preserve the original node data format.
message L4BookDiff {
  uint64 time = 1;
  uint64 height = 2;
  string data = 3;                     // JSON-encoded {order_statuses, book_diffs}
}

// A single L4 order with full details.
message L4Order {
  string user = 1;                     // Ethereum address
  string coin = 2;
  string side = 3;                     // "A" (Ask) or "B" (Bid)
  string limit_px = 4;                 // Limit price as decimal string
  string sz = 5;                       // Size as decimal string
  uint64 oid = 6;                      // Unique order ID
  uint64 timestamp = 7;               // When order entered the book (ms)
  string trigger_condition = 8;        // "N/A", "Triggered", etc.
  bool is_trigger = 9;
  string trigger_px = 10;
  bool is_position_tpsl = 11;
  bool reduce_only = 12;
  string order_type = 13;             // "Limit", "Market", etc.
  optional string tif = 14;           // Time-in-force: "Gtc", "Ioc", "Alo"
  optional string cloid = 15;         // Client order ID
}
